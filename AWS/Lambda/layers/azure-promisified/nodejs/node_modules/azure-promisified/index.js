const azure = require('azure-storage');
const {Chance} = require('chance')
const {camelCase} = require('lodash');

const AZURE_TS_ORGSTABLE = process.env.AZURE_TS_ORGSTABLE;
const AZURE_TS_ORGSTABLE_PARTITIONKEY = process.env.AZURE_TS_ORGSTABLE_PARTITIONKEY;

const tableSvc = azure.createTableService();
const azureEntityGenerator = azure.TableUtilities.entityGenerator;

function createNewOrganization(orgModel) {
    const {nombreCompleto, nombreRecurso} = orgModel;

    const newOrgTask = {
        PartitionKey: azureEntityGenerator.String(AZURE_TS_ORGSTABLE_PARTITIONKEY),
        RowKey: azureEntityGenerator.String(nombreRecurso),
        nombreCompleto: azureEntityGenerator.String(nombreCompleto),
        claveApi: azureEntityGenerator.String(Chance().guid())
    }

    return createEntity(AZURE_TS_ORGSTABLE, newOrgTask)
        .then(_ => fromAzureTSModel(newOrgTask, 'claveApi'));
}

function retrieveOrganization(orgResourceName) {
    return retrieveEntity(AZURE_TS_ORGSTABLE, AZURE_TS_ORGSTABLE_PARTITIONKEY, orgResourceName);
}

function retrieveOrganizationApiKey(orgResourceName) {
    return retrieveOrganization(orgResourceName)
        .then((remoteOrg) => fromAzureTSModel(remoteOrg, "claveApi"));
}

async function organizationExists(orgResourceName) {
    try {
        return !!await retrieveOrganization(orgResourceName);
    } catch (e) {
        return false;
    }
}

function deleteOrganization(orgResourceName) {
    return deleteEntity(AZURE_TS_ORGSTABLE, AZURE_TS_ORGSTABLE_PARTITIONKEY, orgResourceName);
}

async function insertNewTask(org, project, taskModel) {
    const {estado, titulo, descripcion, autor, responsable, prioridad, etiquetas, ...rest} = taskModel;
    const newTaskId = fromAzureTSModel(await retrieveEntity(org, '_metadata', 'secuenciaTarea'), 'valor');

    let processedCustomFields = {};
    for (const customField in rest)
        processedCustomFields[camelCase(customField)] = azureEntityGenerator.String(rest[customField]);

    const taskTask = {
        PartitionKey: azureEntityGenerator.String(project),
        RowKey: azureEntityGenerator.String(String(newTaskId)),
        estado: azureEntityGenerator.String(estado),
        titulo: azureEntityGenerator.String(titulo),
        descripcion: azureEntityGenerator.String(descripcion ? descripcion : ''),
        autor: azureEntityGenerator.String(autor),
        responsable: azureEntityGenerator.String(responsable ? responsable : ''),
        prioridad: azureEntityGenerator.String(prioridad),
        etiquetas: azureEntityGenerator.String(etiquetas ? etiquetas.join(',') : ''),
        ...processedCustomFields
    }

    return createEntity(org, taskTask);
}

function retrieveTask(org, project, taskId) {
    return retrieveEntity(org, project, String(taskId))
        .then(rawEntry => parseTSTaskModel(rawEntry));
}

async function taskExists(org, project, taskId) {
    try {
        return !!await retrieveTask(org, project, String(taskId));
    } catch (e) {
        return false;
    }
}

function updateTask(org, project, taskId, taskModel) {
    const {estado, titulo, descripcion, autor, responsable, prioridad, etiquetas, ...rest} = taskModel;

    let processedCustomFields = {};
    for (const customField in rest)
        processedCustomFields[camelCase(customField)] = azureEntityGenerator.String(rest[customField]);

    const updateTask = {
        PartitionKey: azureEntityGenerator.String(project),
        RowKey: azureEntityGenerator.String(String(taskId)),
        estado: azureEntityGenerator.String(estado),
        titulo: azureEntityGenerator.String(titulo),
        descripcion: azureEntityGenerator.String(descripcion ? descripcion : ''),
        autor: azureEntityGenerator.String(autor),
        responsable: azureEntityGenerator.String(responsable ? responsable : ''),
        prioridad: azureEntityGenerator.String(prioridad),
        etiquetas: azureEntityGenerator.String(etiquetas ? etiquetas.join(',') : ''),
        ...processedCustomFields
    }

    return updateEntityWithReplace(org, updateTask);
}

function deleteTask(org, project, taskId) {
    return deleteEntity(org, project, String(taskId));
}

async function incrementTaskSequence(org) {
    const currentSeqNumber =
        fromAzureTSModel(await retrieveEntity(org, '_metadata', 'secuenciaTarea'), 'valor');

    const updateTask = {
        PartitionKey: azureEntityGenerator.String('_metadata'),
        RowKey: azureEntityGenerator.String('secuenciaTarea'),
        valor: azureEntityGenerator.Int32(currentSeqNumber + 1)
    }

    return updateEntityWithReplace(org, updateTask);
}

function queryTasksOfProject(org, project) {
    return queryTable(org, new azure.TableQuery().where('PartitionKey eq ?', project))
        .then(([rawEntries]) => rawEntries.map(rawEntry => parseTSTaskModel(rawEntry)));
}

function parseTSTaskModel(rawModel) {
    for (const field in rawModel)
        rawModel[field] = fromAzureTSModel(rawModel, field);

    rawModel.id = rawModel.RowKey;
    delete rawModel.RowKey;
    rawModel.proyecto = rawModel.PartitionKey;
    delete rawModel.PartitionKey;

    delete rawModel.Timestamp;

    if (rawModel.etiquetas)
        rawModel.etiquetas = rawModel.etiquetas.split(',');

    return rawModel;
}

function createTable(tableName) {
    return new Promise((resolve, reject) =>
        tableSvc.createTableIfNotExists(tableName, (error, result, response) => {
            if (!error) resolve({result, response})
            else reject({error, response});
        })
    )
}

function deleteTable(tableName) {
    return new Promise((resolve, reject) => {
        tableSvc.deleteTableIfExists(tableName, (error, response) => {
            if (!error) resolve(response)
            else reject(response)
        })
    })
}

function createEntity(table, entityTask) {
    return new Promise((resolve, reject) => {
        tableSvc.insertEntity(table, entityTask, (error, metadata, response) => {
            if (!error) resolve({metadata, response})
            else reject({error, response})
        })
    })
}

function retrieveEntity(table, partitionKey, rowKey) {
    return new Promise((resolve, reject) => {
        tableSvc.retrieveEntity(table, partitionKey, rowKey, (error, result) => {
            if (!error) resolve(result);
            else reject(error);
        });
    });
}

function updateEntityWithReplace(table, updatedTask) {
    return new Promise((resolve, reject) => {
        tableSvc.replaceEntity(table, updatedTask, (error, result, response) => {
            if (!error) resolve({result, response})
            else reject({error, response})
        })
    })
}

function deleteEntity(table, partitionKey, rowKey) {
    return new Promise((resolve, reject) => {
        tableSvc.deleteEntity(table, {PartitionKey: {"_": partitionKey}, RowKey: {"_": rowKey}},
            (error, result) => {
                if (!error) resolve(result);
                else reject(error);
            })
    })
}

async function queryTable(table, query) {
    let continuationToken = null;
    let resultEntries = [];

    const queryOnce = (continuationToken) => new Promise((resolve, reject) => {
        tableSvc.queryEntities(table, query, continuationToken, (error, result, response) => {
            if (!error) resolve({entries: result.entries, nextToken: result.continuationToken});
            else reject({error, response})
        })
    });

    do {
        await queryOnce(continuationToken)
            .then(({entries, nextToken}) => {
                resultEntries.push(entries);
                continuationToken = nextToken;
            })
    } while (continuationToken !== null);

    return resultEntries;
}

function fromAzureTSModel(model, key) {
    return model[key]._;
}

module.exports = {
    createNewOrganization,
    retrieveOrganization,
    retrieveOrganizationApiKey,
    organizationExists,
    deleteOrganization,
    insertNewTask,
    retrieveTask,
    taskExists,
    updateTask,
    deleteTask,
    incrementTaskSequence,
    queryTasksOfProject,
    parseTSTaskModel,
    createTable,
    deleteTable,
    createEntity,
    retrieveEntity,
    updateEntityWithReplace,
    deleteEntity,
    queryTable,
    fromAzureTSModel,
    azureEntityGenerator,
    AZURE_TS_ORGSTABLE,
    AZURE_TS_ORGSTABLE_PARTITIONKEY,
};